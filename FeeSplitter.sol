//SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Ownable2Step} from "@openzeppelin/contracts@v4.9.3/access/Ownable2Step.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts@v4.9.3/security/ReentrancyGuard.sol";
import {SafeERC20} from "@openzeppelin/contracts@v4.9.3/token/ERC20/utils/SafeERC20.sol";
import {IERC20} from "@openzeppelin/contracts@v4.9.3/token/ERC20/IERC20.sol";

contract FeeSplitter is Ownable2Step, ReentrancyGuard {

    using SafeERC20 for IERC20;

    /**
     * @custom:section                           ** ERRORS **
     */
    error CantSetAddressZero();
    error ZeroProfitDivider();

    /**
     * @custom:section                           ** IMMUTABLES **
     */
    IERC20 private immutable _PTOKEN;

    /**
     * @custom:section                           ** PRIVATE VARIABLES **
     */
    address private BRIBES;
    address private PANTHEON;
    address private EQUALDAO;

    uint256 private ProfitDivider;

    /**
     * @custom:section                           ** PUBLIC VARIABLES **
     */
    uint256 public totalBribes;

    /**
     * @custom:section                           ** EVENTS **
     */
    event FeeSent(
        uint256 indexed time,
        uint256 indexed AmountSentToPantheonAndEqualDao,
        uint256 indexed AmountSentToBribing
    );
    event ProfitDividerUpdated(uint256 indexed ProfitDivider);
    event PantheonAddressUpdated(address indexed PantheonAddress);
    event EqualDaoAddressUpdated(address indexed EqualDaoAddress);
    event BribingAddressUpdated(address indexed BribingAddress);


    /**
     * @custom:section                           ** CONSTRUCTOR **
     */
    constructor(address _pToken) {
        _PTOKEN = IERC20(_pToken);
    }

    /**
     * @custom:section                           ** EXTERNAL FUNCTIONS **
     */

    /**
     * @notice this function splits the revenue generated by pTOKEN.sol into the Bribing Wallet and the Pantheon & =DAO wallets
     */
    function splitFees() external onlyOwner {
        uint256 profit = _PTOKEN.balanceOf(address(this)) / ProfitDivider;

        SafeERC20.safeTransfer(_PTOKEN, EQUALDAO, profit / 2);
        SafeERC20.safeTransfer(_PTOKEN, PANTHEON, profit / 2);

        uint256 remaining = _PTOKEN.balanceOf(address(this));

        SafeERC20.safeTransfer(_PTOKEN, BRIBES, remaining);
        totalBribes += remaining;

        emit FeeSent(block.timestamp, profit, remaining);
    }

    /**
     * @notice this function lets the owner set the ProfitDivider variable that is used to calculate the amount sent to the Pantheon & =DAO wallets
     */
    function setProfitDivider(uint256 _value) external onlyOwner {
        if(_value == 0) revert ZeroProfitDivider();  
        ProfitDivider = _value;

        emit ProfitDividerUpdated(_value);
    }

    /**
     * @notice this function lets the owner set the Bribing Wallet
     */
    function setBribingWallet(address _address) external onlyOwner {
        if(_address == address(0x0)) revert CantSetAddressZero();
        BRIBES = (_address);

        emit BribingAddressUpdated(_address);
    }

    /**
     * @notice this function lets the owner set the Pantheon Wallet
     */
    function setPantheonWallet(address _address) external onlyOwner {
        if(_address == address(0x0)) revert CantSetAddressZero();
        PANTHEON = (_address);

        emit PantheonAddressUpdated(_address);
    }

    /**
     * @notice this function lets the owner set the =DAO Wallet
     */
    function setEqualDaoWallet(address _address) external onlyOwner {
        if(_address == address(0x0)) revert CantSetAddressZero();
        EQUALDAO = (_address);

        emit EqualDaoAddressUpdated(_address);
    }
}